name: Release App

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.0-beta.1)'
        required: true
        type: string
      dry_run:
        description: 'Dry run (build without releasing)'
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  OCCT_VERSION: "7.9.2"

jobs:
  # ============================================================================
  # Windows Build
  # ============================================================================
  build-windows:
    name: Build (Windows x64)
    runs-on: windows-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.1

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          target: x86_64-pc-windows-msvc

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            . -> target
            apps/desktop/src-tauri -> apps/desktop/src-tauri/target

      # Cache OCCT download to speed up builds (~570MB download)
      - name: Cache OpenCASCADE
        id: cache-occt
        uses: actions/cache@v4
        with:
          path: deps/occt-${{ env.OCCT_VERSION }}
          key: occt-windows-${{ env.OCCT_VERSION }}

      - name: Setup OpenCASCADE
        if: steps.cache-occt.outputs.cache-hit != 'true'
        shell: powershell
        run: .\scripts\occt\setup.ps1

      - name: Copy OCCT DLLs for bundling
        shell: powershell
        run: .\scripts\occt\copy-dlls.ps1

      - name: Setup Node.js for native modules
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Dependencies
        run: bun install --frozen-lockfile
        env:
          HUSKY: 0
          npm_config_python: python
          npm_config_msvs_version: 2022

      - name: Build App
        shell: powershell
        env:
          OCCT_ROOT: ${{ github.workspace }}\deps\occt-${{ env.OCCT_VERSION }}
          DEP_OCCT_ROOT: ${{ github.workspace }}\deps\occt-${{ env.OCCT_VERSION }}
          CASROOT: ${{ github.workspace }}\deps\occt-${{ env.OCCT_VERSION }}
          # Tauri signing keys for auto-updater
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: .\scripts\dev\run-with-occt.ps1 "bun run --filter @cadhy/desktop tauri:build"

      - name: Get version
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          fi

      - name: Prepare Windows artifacts
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          mkdir -p release-files

          # NSIS installer
          cp target/release/bundle/nsis/*.exe "release-files/CADHY_${VERSION}_x64-setup.exe" 2>/dev/null || true
          cp target/release/bundle/nsis/*.exe.sig "release-files/CADHY_${VERSION}_x64-setup.exe.sig" 2>/dev/null || true

          # MSI installer
          cp target/release/bundle/msi/*.msi "release-files/CADHY_${VERSION}_x64_en-US.msi" 2>/dev/null || true
          cp target/release/bundle/msi/*.msi.sig "release-files/CADHY_${VERSION}_x64_en-US.msi.sig" 2>/dev/null || true

          ls -la release-files/

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-binaries
          path: release-files/*
          if-no-files-found: error

  # ============================================================================
  # macOS Build (ARM64 only - Intel x64 disabled due to runner costs)
  # ============================================================================
  build-macos:
    name: Build (macOS ${{ matrix.arch }})
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: write

    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            arch: arm64
            runner: macos-14

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.1

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          target: ${{ matrix.target }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            . -> target
            apps/desktop/src-tauri -> apps/desktop/src-tauri/target

      - name: Cache Homebrew packages
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/Homebrew
            /opt/homebrew/Cellar/opencascade
            /opt/homebrew/Cellar/freetype
            /opt/homebrew/Cellar/libpng
            /opt/homebrew/Cellar/tbb
          key: homebrew-occt-deps-${{ runner.os }}-${{ runner.arch }}-v2
          restore-keys: |
            homebrew-occt-deps-${{ runner.os }}-

      - name: Install OpenCASCADE via Homebrew
        run: |
          brew update
          brew install opencascade freetype libpng tbb
          echo "OCCT installed at: $(brew --prefix opencascade)"
          echo "Freetype installed at: $(brew --prefix freetype)"
          echo "libpng installed at: $(brew --prefix libpng)"
          echo "TBB installed at: $(brew --prefix tbb)"

      - name: Install Dependencies
        run: bun install --frozen-lockfile
        env:
          HUSKY: 0

      - name: Copy OCCT dylibs for bundling
        run: |
          chmod +x scripts/occt/copy-dylibs-macos.sh
          ./scripts/occt/copy-dylibs-macos.sh

      - name: Import Apple Certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          if [ -n "$APPLE_CERTIFICATE" ]; then
            echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
            security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
            security default-keychain -s build.keychain
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
            security set-keychain-settings -t 3600 -u build.keychain
            security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
            rm certificate.p12
          else
            echo "No Apple certificate provided, skipping code signing setup"
          fi

      - name: Build App and DMG
        env:
          # Tauri signing keys for auto-updater
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # Apple code signing (signing works, notarization disabled for now)
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # Apple notarization - disabled: first-time notarization can take hours
          # Re-enable after first successful notarization:
          # APPLE_ID: ${{ secrets.APPLE_ID }}
          # APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          # APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Build app bundle only first (no DMG yet)
          bun run --filter @cadhy/desktop tauri:build:macos -- --target ${{ matrix.target }} --bundles app

      - name: Fix dylib paths and re-sign
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          chmod +x scripts/occt/fix-dylib-paths-macos.sh
          ./scripts/occt/fix-dylib-paths-macos.sh "target/${{ matrix.target }}/release/bundle/macos/CADHY.app"

      - name: Create DMG from fixed app
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          APP_PATH="target/${{ matrix.target }}/release/bundle/macos/CADHY.app"
          DMG_DIR="target/${{ matrix.target }}/release/bundle/dmg"
          mkdir -p "$DMG_DIR"
          
          # Get version from tauri.conf.json
          VERSION=$(grep -o '"version": "[^"]*"' apps/desktop/src-tauri/tauri.conf.json | head -1 | cut -d'"' -f4)
          DMG_NAME="CADHY_${VERSION}_${{ matrix.arch == 'arm64' && 'aarch64' || 'x64' }}.dmg"
          
          # Create DMG using hdiutil (macOS native tool)
          echo "Creating DMG from fixed app bundle..."
          
          # Create a temporary directory for DMG contents
          TEMP_DMG_DIR=$(mktemp -d)
          cp -R "$APP_PATH" "$TEMP_DMG_DIR/"
          ln -s /Applications "$TEMP_DMG_DIR/Applications"
          
          # Create the DMG
          hdiutil create -volname "CADHY" -srcfolder "$TEMP_DMG_DIR" -ov -format UDZO "$DMG_DIR/$DMG_NAME"
          
          # Sign the DMG if we have an identity
          if [ -n "$APPLE_SIGNING_IDENTITY" ]; then
            codesign --force --sign "$APPLE_SIGNING_IDENTITY" "$DMG_DIR/$DMG_NAME"
          else
            codesign --force --sign - "$DMG_DIR/$DMG_NAME"
          fi
          
          # Cleanup
          rm -rf "$TEMP_DMG_DIR"
          
          echo "DMG created: $DMG_DIR/$DMG_NAME"
          ls -la "$DMG_DIR/"

      - name: Create app.tar.gz for auto-updater
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          APP_PATH="target/${{ matrix.target }}/release/bundle/macos/CADHY.app"
          BUNDLE_DIR="target/${{ matrix.target }}/release/bundle/macos"
          
          # Get version
          VERSION=$(grep -o '"version": "[^"]*"' apps/desktop/src-tauri/tauri.conf.json | head -1 | cut -d'"' -f4)
          TARBALL_NAME="CADHY.app.tar.gz"
          
          # Create tarball
          cd "$BUNDLE_DIR"
          tar -czf "$TARBALL_NAME" "CADHY.app"
          
          # Sign for auto-updater if we have the key
          if [ -n "$TAURI_SIGNING_PRIVATE_KEY" ]; then
            echo "Signing tarball for auto-updater..."
            # Use tauri's signer if available, otherwise skip
            if command -v tauri &> /dev/null; then
              tauri signer sign "$TARBALL_NAME" --private-key "$TAURI_SIGNING_PRIVATE_KEY" --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" || echo "Signing failed, continuing..."
            fi
          fi
          
          echo "Tarball created: $BUNDLE_DIR/$TARBALL_NAME"
          ls -la

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          fi

      - name: Prepare macOS artifacts
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ARCH="${{ matrix.arch == 'arm64' && 'aarch64' || 'x64' }}"
          mkdir -p release-files

          # DMG installer
          cp target/${{ matrix.target }}/release/bundle/dmg/*.dmg "release-files/CADHY_${VERSION}_${ARCH}.dmg" 2>/dev/null || true
          cp target/${{ matrix.target }}/release/bundle/dmg/*.dmg.sig "release-files/CADHY_${VERSION}_${ARCH}.dmg.sig" 2>/dev/null || true

          # App bundle for auto-updater (critical!)
          cp target/${{ matrix.target }}/release/bundle/macos/*.app.tar.gz "release-files/CADHY_${VERSION}_${ARCH}.app.tar.gz" 2>/dev/null || true
          cp target/${{ matrix.target }}/release/bundle/macos/*.app.tar.gz.sig "release-files/CADHY_${VERSION}_${ARCH}.app.tar.gz.sig" 2>/dev/null || true

          echo "=== Release files ==="
          ls -la release-files/

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-binaries-${{ matrix.arch }}
          path: release-files/*
          if-no-files-found: warn

  # ============================================================================
  # Create GitHub Release with Update Manifest
  # ============================================================================
  release:
    name: Create Release
    needs: [build-windows, build-macos]
    runs-on: ubuntu-latest
    if: |
      always() &&
      (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch') &&
      github.event.inputs.dry_run != 'true' &&
      (needs.build-macos.result == 'success' || needs.build-windows.result == 'success')
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: |
          echo "=== All artifacts ==="
          ls -laR artifacts/

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          fi

      - name: Extract changelog for version
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [ -f "CHANGELOG.md" ]; then
            CHANGELOG=$(awk "/## \[${VERSION}\]/{flag=1; next} /## \[/{flag=0} flag" CHANGELOG.md)
            if [ -z "$CHANGELOG" ]; then
              CHANGELOG="Release v${VERSION}"
            fi
          else
            CHANGELOG="Release v${VERSION}"
          fi
          echo "$CHANGELOG" > changelog_body.txt
          echo "changelog_file=changelog_body.txt" >> $GITHUB_OUTPUT

      - name: Generate update manifest (latest.json)
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          RELEASES_REPO="${{ github.repository }}"

          # Build platforms object dynamically based on available artifacts
          PLATFORMS="{"
          FIRST=true

          # macOS arm64 (for auto-updater, uses .app.tar.gz)
          if [ -f "artifacts/macos-binaries-arm64/CADHY_${VERSION}_aarch64.app.tar.gz.sig" ]; then
            SIG=$(cat "artifacts/macos-binaries-arm64/CADHY_${VERSION}_aarch64.app.tar.gz.sig")
            if [ "$FIRST" = false ]; then PLATFORMS+=","; fi
            PLATFORMS+="\"darwin-aarch64\":{\"signature\":\"$SIG\",\"url\":\"https://github.com/${RELEASES_REPO}/releases/download/v${VERSION}/CADHY_${VERSION}_aarch64.app.tar.gz\"}"
            FIRST=false
            echo "Added darwin-aarch64 to manifest"
          fi

          # macOS x64 (if built)
          if [ -f "artifacts/macos-binaries-x64/CADHY_${VERSION}_x64.app.tar.gz.sig" ]; then
            SIG=$(cat "artifacts/macos-binaries-x64/CADHY_${VERSION}_x64.app.tar.gz.sig")
            if [ "$FIRST" = false ]; then PLATFORMS+=","; fi
            PLATFORMS+="\"darwin-x86_64\":{\"signature\":\"$SIG\",\"url\":\"https://github.com/${RELEASES_REPO}/releases/download/v${VERSION}/CADHY_${VERSION}_x64.app.tar.gz\"}"
            FIRST=false
            echo "Added darwin-x86_64 to manifest"
          fi

          # Windows (uses .exe for auto-updater)
          if [ -f "artifacts/windows-binaries/CADHY_${VERSION}_x64-setup.exe.sig" ]; then
            SIG=$(cat "artifacts/windows-binaries/CADHY_${VERSION}_x64-setup.exe.sig")
            if [ "$FIRST" = false ]; then PLATFORMS+=","; fi
            PLATFORMS+="\"windows-x86_64\":{\"signature\":\"$SIG\",\"url\":\"https://github.com/${RELEASES_REPO}/releases/download/v${VERSION}/CADHY_${VERSION}_x64-setup.exe\"}"
            FIRST=false
            echo "Added windows-x86_64 to manifest"
          fi

          PLATFORMS+="}"

          # Generate latest.json
          cat > artifacts/latest.json << EOF
          {
            "version": "${VERSION}",
            "notes": "See the release notes at https://github.com/${RELEASES_REPO}/releases/tag/v${VERSION}",
            "pub_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "platforms": ${PLATFORMS}
          }
          EOF

          echo "=== Generated latest.json ==="
          cat artifacts/latest.json

      - name: Collect release files
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          mkdir -p release-upload

          # Copy all artifacts to release folder
          cp artifacts/windows-binaries/* release-upload/ 2>/dev/null || true
          cp artifacts/macos-binaries-arm64/* release-upload/ 2>/dev/null || true
          cp artifacts/macos-binaries-x64/* release-upload/ 2>/dev/null || true
          cp artifacts/latest.json release-upload/

          echo "=== Files to upload ==="
          ls -la release-upload/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: CADHY v${{ steps.version.outputs.version }}
          body_path: changelog_body.txt
          files: release-upload/*
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, 'alpha') || contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
