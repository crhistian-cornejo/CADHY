//! Wavefront OBJ Export Module

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

use crate::{ExportMesh, Result};

/// Export mesh to Wavefront OBJ format
pub fn export<P: AsRef<Path>>(mesh: &ExportMesh, path: P) -> Result<()> {
    mesh.validate()?;

    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    writeln!(writer, "# Generated by CADHY")?;
    writeln!(writer, "# Vertices: {}", mesh.vertices.len())?;
    writeln!(writer, "# Triangles: {}", mesh.indices.len() / 3)?;
    writeln!(writer)?;

    // Write vertices
    for v in &mesh.vertices {
        writeln!(writer, "v {} {} {}", v[0], v[1], v[2])?;
    }

    writeln!(writer)?;

    // Write normals if present
    if let Some(ref normals) = mesh.normals {
        for n in normals {
            writeln!(writer, "vn {} {} {}", n[0], n[1], n[2])?;
        }
        writeln!(writer)?;
    }

    // Write faces (OBJ uses 1-based indexing)
    if mesh.normals.is_some() {
        for tri in mesh.indices.chunks(3) {
            writeln!(
                writer,
                "f {}//{} {}//{} {}//{}",
                tri[0] + 1,
                tri[0] + 1,
                tri[1] + 1,
                tri[1] + 1,
                tri[2] + 1,
                tri[2] + 1
            )?;
        }
    } else {
        for tri in mesh.indices.chunks(3) {
            writeln!(writer, "f {} {} {}", tri[0] + 1, tri[1] + 1, tri[2] + 1)?;
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_test_mesh() -> ExportMesh {
        ExportMesh::new(
            vec![[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.5, 1.0, 0.0]],
            vec![0, 1, 2],
        )
    }

    #[test]
    fn test_export_obj() {
        let mesh = make_test_mesh();
        let temp_dir = tempfile::tempdir().unwrap();
        let path = temp_dir.path().join("test.obj");

        export(&mesh, &path).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("# Generated by CADHY"));
        assert!(content.contains("v 0 0 0"));
        assert!(content.contains("f 1 2 3"));
    }

    #[test]
    fn test_export_obj_with_normals() {
        let mesh = ExportMesh::new(
            vec![[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.5, 1.0, 0.0]],
            vec![0, 1, 2],
        )
        .with_normals(vec![[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0]]);

        let temp_dir = tempfile::tempdir().unwrap();
        let path = temp_dir.path().join("test_normals.obj");

        export(&mesh, &path).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("vn 0 0 1"));
        assert!(content.contains("f 1//1 2//2 3//3"));
    }
}
