//! Surface mesh export functionality
//!
//! Supports exporting surface meshes to common formats:
//! - STL (ASCII and binary)
//! - OBJ (Wavefront)
//! - PLY (ASCII)

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

use crate::error::Result;
use crate::types::{SurfaceMesh, Vertex};

/// Supported export formats for surface meshes
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ExportFormat {
    /// STL surface mesh (ASCII)
    StlAscii,
    /// STL surface mesh (binary)
    StlBinary,
    /// Wavefront OBJ
    Obj,
    /// PLY (ASCII)
    Ply,
}

impl ExportFormat {
    /// Get file extension for format
    pub fn extension(&self) -> &'static str {
        match self {
            ExportFormat::StlAscii | ExportFormat::StlBinary => "stl",
            ExportFormat::Obj => "obj",
            ExportFormat::Ply => "ply",
        }
    }

    /// Detect format from file extension
    pub fn from_extension(ext: &str) -> Option<Self> {
        match ext.to_lowercase().as_str() {
            "stl" => Some(ExportFormat::StlAscii),
            "obj" => Some(ExportFormat::Obj),
            "ply" => Some(ExportFormat::Ply),
            _ => None,
        }
    }
}

/// Export surface mesh to file (format auto-detected from extension)
pub fn export_mesh<P: AsRef<Path>>(mesh: &SurfaceMesh, path: P) -> Result<()> {
    let path = path.as_ref();
    let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("stl");

    let format = ExportFormat::from_extension(ext).unwrap_or(ExportFormat::StlAscii);

    match format {
        ExportFormat::StlAscii => export_stl_ascii(mesh, path),
        ExportFormat::StlBinary => export_stl_binary(mesh, path),
        ExportFormat::Obj => export_obj(mesh, path),
        ExportFormat::Ply => export_ply(mesh, path),
    }
}

/// Export surface mesh to ASCII STL format
pub fn export_stl_ascii<P: AsRef<Path>>(mesh: &SurfaceMesh, path: P) -> Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    writeln!(writer, "solid mesh")?;

    for tri in &mesh.triangles {
        let v0 = &mesh.vertices[tri.i0 as usize];
        let v1 = &mesh.vertices[tri.i1 as usize];
        let v2 = &mesh.vertices[tri.i2 as usize];

        // Compute normal
        let normal = compute_triangle_normal(v0, v1, v2);

        writeln!(
            writer,
            "  facet normal {} {} {}",
            normal.x, normal.y, normal.z
        )?;
        writeln!(writer, "    outer loop")?;
        writeln!(writer, "      vertex {} {} {}", v0.x, v0.y, v0.z)?;
        writeln!(writer, "      vertex {} {} {}", v1.x, v1.y, v1.z)?;
        writeln!(writer, "      vertex {} {} {}", v2.x, v2.y, v2.z)?;
        writeln!(writer, "    endloop")?;
        writeln!(writer, "  endfacet")?;
    }

    writeln!(writer, "endsolid mesh")?;

    Ok(())
}

/// Export surface mesh to binary STL format
pub fn export_stl_binary<P: AsRef<Path>>(mesh: &SurfaceMesh, path: P) -> Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    // 80-byte header
    let header = [0u8; 80];
    writer.write_all(&header)?;

    // Number of triangles (u32 little-endian)
    let num_triangles = mesh.triangles.len() as u32;
    writer.write_all(&num_triangles.to_le_bytes())?;

    for tri in &mesh.triangles {
        let v0 = &mesh.vertices[tri.i0 as usize];
        let v1 = &mesh.vertices[tri.i1 as usize];
        let v2 = &mesh.vertices[tri.i2 as usize];

        // Compute normal
        let normal = compute_triangle_normal(v0, v1, v2);

        // Write normal (3x f32)
        writer.write_all(&(normal.x as f32).to_le_bytes())?;
        writer.write_all(&(normal.y as f32).to_le_bytes())?;
        writer.write_all(&(normal.z as f32).to_le_bytes())?;

        // Write vertices (3x 3x f32)
        writer.write_all(&(v0.x as f32).to_le_bytes())?;
        writer.write_all(&(v0.y as f32).to_le_bytes())?;
        writer.write_all(&(v0.z as f32).to_le_bytes())?;

        writer.write_all(&(v1.x as f32).to_le_bytes())?;
        writer.write_all(&(v1.y as f32).to_le_bytes())?;
        writer.write_all(&(v1.z as f32).to_le_bytes())?;

        writer.write_all(&(v2.x as f32).to_le_bytes())?;
        writer.write_all(&(v2.y as f32).to_le_bytes())?;
        writer.write_all(&(v2.z as f32).to_le_bytes())?;

        // Attribute byte count (unused, set to 0)
        writer.write_all(&[0u8, 0u8])?;
    }

    Ok(())
}

/// Export surface mesh to Wavefront OBJ format
pub fn export_obj<P: AsRef<Path>>(mesh: &SurfaceMesh, path: P) -> Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    writeln!(writer, "# Generated by GraphCAD")?;
    writeln!(writer, "# Vertices: {}", mesh.vertices.len())?;
    writeln!(writer, "# Triangles: {}", mesh.triangles.len())?;
    writeln!(writer)?;

    // Write vertices
    for v in &mesh.vertices {
        writeln!(writer, "v {} {} {}", v.x, v.y, v.z)?;
    }

    writeln!(writer)?;

    // Write normals if present
    if let Some(ref normals) = mesh.normals {
        for n in normals {
            writeln!(writer, "vn {} {} {}", n[0], n[1], n[2])?;
        }
        writeln!(writer)?;
    }

    // Write faces (OBJ uses 1-based indexing)
    if mesh.normals.is_some() {
        for tri in &mesh.triangles {
            writeln!(
                writer,
                "f {}//{} {}//{} {}//{}",
                tri.i0 + 1,
                tri.i0 + 1,
                tri.i1 + 1,
                tri.i1 + 1,
                tri.i2 + 1,
                tri.i2 + 1
            )?;
        }
    } else {
        for tri in &mesh.triangles {
            writeln!(writer, "f {} {} {}", tri.i0 + 1, tri.i1 + 1, tri.i2 + 1)?;
        }
    }

    Ok(())
}

/// Export surface mesh to PLY format (ASCII)
pub fn export_ply<P: AsRef<Path>>(mesh: &SurfaceMesh, path: P) -> Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    // PLY header
    writeln!(writer, "ply")?;
    writeln!(writer, "format ascii 1.0")?;
    writeln!(writer, "comment Generated by GraphCAD")?;
    writeln!(writer, "element vertex {}", mesh.vertices.len())?;
    writeln!(writer, "property float x")?;
    writeln!(writer, "property float y")?;
    writeln!(writer, "property float z")?;

    if mesh.normals.is_some() {
        writeln!(writer, "property float nx")?;
        writeln!(writer, "property float ny")?;
        writeln!(writer, "property float nz")?;
    }

    writeln!(writer, "element face {}", mesh.triangles.len())?;
    writeln!(writer, "property list uchar int vertex_indices")?;
    writeln!(writer, "end_header")?;

    // Write vertices
    if let Some(ref normals) = mesh.normals {
        for (v, n) in mesh.vertices.iter().zip(normals.iter()) {
            writeln!(
                writer,
                "{} {} {} {} {} {}",
                v.x as f32, v.y as f32, v.z as f32, n[0], n[1], n[2]
            )?;
        }
    } else {
        for v in &mesh.vertices {
            writeln!(writer, "{} {} {}", v.x as f32, v.y as f32, v.z as f32)?;
        }
    }

    // Write faces
    for tri in &mesh.triangles {
        writeln!(writer, "3 {} {} {}", tri.i0, tri.i1, tri.i2)?;
    }

    Ok(())
}

/// Compute normal vector for a triangle
fn compute_triangle_normal(v0: &Vertex, v1: &Vertex, v2: &Vertex) -> Vertex {
    let e1 = Vertex::new(v1.x - v0.x, v1.y - v0.y, v1.z - v0.z);
    let e2 = Vertex::new(v2.x - v0.x, v2.y - v0.y, v2.z - v0.z);

    let nx = e1.y * e2.z - e1.z * e2.y;
    let ny = e1.z * e2.x - e1.x * e2.z;
    let nz = e1.x * e2.y - e1.y * e2.x;

    let len = (nx * nx + ny * ny + nz * nz).sqrt();

    if len > 1e-10 {
        Vertex::new(nx / len, ny / len, nz / len)
    } else {
        Vertex::new(0.0, 0.0, 1.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Triangle;
    use std::fs;

    fn make_test_mesh() -> SurfaceMesh {
        SurfaceMesh {
            vertices: vec![
                Vertex::new(0.0, 0.0, 0.0),
                Vertex::new(1.0, 0.0, 0.0),
                Vertex::new(0.5, 1.0, 0.0),
            ],
            triangles: vec![Triangle::new(0, 1, 2)],
            normals: None,
            metadata: Default::default(),
        }
    }

    #[test]
    fn test_export_stl_ascii() {
        let mesh = make_test_mesh();
        let path = std::env::temp_dir().join("test_mesh.stl");
        export_stl_ascii(&mesh, &path).unwrap();

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("solid mesh"));
        assert!(content.contains("facet normal"));
        assert!(content.contains("endsolid mesh"));

        fs::remove_file(path).ok();
    }

    #[test]
    fn test_export_obj() {
        let mesh = make_test_mesh();
        let path = std::env::temp_dir().join("test_mesh.obj");
        export_obj(&mesh, &path).unwrap();

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("v 0 0 0"));
        assert!(content.contains("f 1 2 3"));

        fs::remove_file(path).ok();
    }

    #[test]
    fn test_export_ply() {
        let mesh = make_test_mesh();
        let path = std::env::temp_dir().join("test_mesh.ply");
        export_ply(&mesh, &path).unwrap();

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("ply"));
        assert!(content.contains("element vertex 3"));
        assert!(content.contains("element face 1"));

        fs::remove_file(path).ok();
    }
}
