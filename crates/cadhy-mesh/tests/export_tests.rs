//! Tests for mesh export functionality

use cadhy_mesh::export::*;
use cadhy_mesh::types::*;
use std::fs;
use std::path::PathBuf;

fn create_test_surface_mesh() -> SurfaceMesh {
    SurfaceMesh {
        vertices: vec![
            Vertex::new(0.0, 0.0, 0.0),
            Vertex::new(1.0, 0.0, 0.0),
            Vertex::new(0.5, 0.866, 0.0),
            Vertex::new(0.5, 0.289, 0.816),
        ],
        triangles: vec![
            Triangle::new(0, 1, 2), // base
            Triangle::new(0, 1, 3), // front
            Triangle::new(1, 2, 3), // right
            Triangle::new(0, 2, 3), // left
        ],
        normals: None,
        metadata: Default::default(),
    }
}

fn unique_temp_path(name: &str) -> PathBuf {
    let id = std::process::id();
    let thread_id = format!("{:?}", std::thread::current().id());
    let unique = format!(
        "{}_{}_{}_{}",
        name,
        id,
        thread_id.replace(|c: char| !c.is_alphanumeric(), ""),
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos()
    );
    std::env::temp_dir().join(unique)
}

#[test]
fn test_export_stl_ascii() {
    let mesh = create_test_surface_mesh();
    let path = unique_temp_path("test_mesh.stl");

    let result = export_stl_ascii(&mesh, &path);
    assert!(
        result.is_ok(),
        "STL ASCII export failed: {:?}",
        result.err()
    );

    // Verify file was created
    assert!(path.exists(), "STL file was not created at {:?}", path);

    // Read and verify content
    let content = fs::read_to_string(&path).unwrap();
    assert!(content.contains("solid mesh"));
    assert!(content.contains("facet normal"));
    assert!(content.contains("vertex"));
    assert!(content.contains("endsolid mesh"));

    // Should have 4 triangles
    let facet_count = content.matches("facet normal").count();
    assert_eq!(facet_count, 4);

    // Cleanup
    let _ = fs::remove_file(&path);
}

#[test]
fn test_export_stl_binary() {
    let mesh = create_test_surface_mesh();
    let path = unique_temp_path("test_mesh_binary.stl");

    let result = export_stl_binary(&mesh, &path);
    assert!(
        result.is_ok(),
        "STL binary export failed: {:?}",
        result.err()
    );

    // Verify file was created
    assert!(path.exists(), "STL binary file was not created");

    // Read file and verify size
    // Binary STL: 80 header + 4 bytes count + (50 bytes * num_triangles)
    let data = fs::read(&path).unwrap();
    let expected_size = 80 + 4 + (50 * 4); // 4 triangles
    assert_eq!(data.len(), expected_size);

    // Verify triangle count in header
    let count = u32::from_le_bytes([data[80], data[81], data[82], data[83]]);
    assert_eq!(count, 4);

    // Cleanup
    let _ = fs::remove_file(&path);
}

#[test]
fn test_export_obj() {
    let mesh = create_test_surface_mesh();
    let path = unique_temp_path("test_mesh.obj");

    let result = export_obj(&mesh, &path);
    assert!(result.is_ok(), "OBJ export failed: {:?}", result.err());

    // Verify file was created
    assert!(path.exists(), "OBJ file was not created");

    // Read and verify content
    let content = fs::read_to_string(&path).unwrap();
    assert!(content.contains("# Generated by GraphCAD"));

    // Should have 4 vertices
    let vertex_count = content.lines().filter(|l| l.starts_with("v ")).count();
    assert_eq!(vertex_count, 4);

    // Should have 4 faces
    let face_count = content.lines().filter(|l| l.starts_with("f ")).count();
    assert_eq!(face_count, 4);

    // OBJ uses 1-based indices
    assert!(content.contains("f 1 2 3"));

    // Cleanup
    let _ = fs::remove_file(&path);
}

#[test]
fn test_export_ply() {
    let mesh = create_test_surface_mesh();
    let path = unique_temp_path("test_mesh.ply");

    let result = export_ply(&mesh, &path);
    assert!(result.is_ok(), "PLY export failed: {:?}", result.err());

    // Verify file was created
    assert!(path.exists(), "PLY file was not created");

    // Read and verify content
    let content = fs::read_to_string(&path).unwrap();
    assert!(content.contains("ply"));
    assert!(content.contains("format ascii 1.0"));
    assert!(content.contains("element vertex 4"));
    assert!(content.contains("element face 4"));
    assert!(content.contains("end_header"));

    // Cleanup
    let _ = fs::remove_file(&path);
}

#[test]
fn test_export_mesh_auto_detect() {
    let mesh = create_test_surface_mesh();

    // Test STL detection
    let stl_path = unique_temp_path("auto.stl");
    let result = export_mesh(&mesh, &stl_path);
    assert!(result.is_ok());
    assert!(stl_path.exists());
    let _ = fs::remove_file(&stl_path);

    // Test OBJ detection
    let obj_path = unique_temp_path("auto.obj");
    let result = export_mesh(&mesh, &obj_path);
    assert!(result.is_ok());
    assert!(obj_path.exists());
    let _ = fs::remove_file(&obj_path);

    // Test PLY detection
    let ply_path = unique_temp_path("auto.ply");
    let result = export_mesh(&mesh, &ply_path);
    assert!(result.is_ok());
    assert!(ply_path.exists());
    let _ = fs::remove_file(&ply_path);
}

#[test]
fn test_export_format_extensions() {
    assert_eq!(ExportFormat::StlAscii.extension(), "stl");
    assert_eq!(ExportFormat::StlBinary.extension(), "stl");
    assert_eq!(ExportFormat::Obj.extension(), "obj");
    assert_eq!(ExportFormat::Ply.extension(), "ply");
}

#[test]
fn test_export_format_from_extension() {
    assert_eq!(
        ExportFormat::from_extension("stl"),
        Some(ExportFormat::StlAscii)
    );
    assert_eq!(
        ExportFormat::from_extension("STL"),
        Some(ExportFormat::StlAscii)
    );
    assert_eq!(ExportFormat::from_extension("obj"), Some(ExportFormat::Obj));
    assert_eq!(ExportFormat::from_extension("OBJ"), Some(ExportFormat::Obj));
    assert_eq!(ExportFormat::from_extension("ply"), Some(ExportFormat::Ply));
    assert_eq!(ExportFormat::from_extension("PLY"), Some(ExportFormat::Ply));
    assert_eq!(ExportFormat::from_extension("xyz"), None);
}

#[test]
fn test_export_empty_mesh() {
    let mesh = SurfaceMesh::empty();
    let path = unique_temp_path("empty_mesh.stl");

    let result = export_stl_ascii(&mesh, &path);
    assert!(result.is_ok(), "Export of empty mesh should succeed");

    let content = fs::read_to_string(&path).unwrap();
    assert!(content.contains("solid mesh"));
    assert!(content.contains("endsolid mesh"));
    // No triangles
    assert!(!content.contains("facet normal"));

    // Cleanup
    let _ = fs::remove_file(&path);
}

#[test]
fn test_export_mesh_with_normals() {
    let mesh = SurfaceMesh {
        vertices: vec![
            Vertex::new(0.0, 0.0, 0.0),
            Vertex::new(1.0, 0.0, 0.0),
            Vertex::new(0.5, 1.0, 0.0),
        ],
        triangles: vec![Triangle::new(0, 1, 2)],
        normals: Some(vec![[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0]]),
        metadata: Default::default(),
    };

    // OBJ with normals
    let obj_path = unique_temp_path("with_normals.obj");
    let result = export_obj(&mesh, &obj_path);
    assert!(result.is_ok());

    let content = fs::read_to_string(&obj_path).unwrap();
    assert!(content.contains("vn 0 0 1")); // Has normals
    assert!(content.contains("f 1//1")); // Face references normals

    let _ = fs::remove_file(&obj_path);

    // PLY with normals
    let ply_path = unique_temp_path("with_normals.ply");
    let result = export_ply(&mesh, &ply_path);
    assert!(result.is_ok());

    let content = fs::read_to_string(&ply_path).unwrap();
    assert!(content.contains("property float nx"));

    let _ = fs::remove_file(&ply_path);
}
